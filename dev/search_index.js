var documenterSearchIndex = {"docs":
[{"location":"manual/saddlesystems/#Saddle-point-systems-1","page":"Saddle point systems","title":"Saddle point systems","text":"","category":"section"},{"location":"manual/saddlesystems/#","page":"Saddle point systems","title":"Saddle point systems","text":"DocTestSetup = quote\nusing CartesianGrids\nusing ConstrainedSystems\nend","category":"page"},{"location":"manual/saddlesystems/#","page":"Saddle point systems","title":"Saddle point systems","text":"defddt1fracmathrmd1mathrmdt\n\nrenewcommandvecboldsymbol\nnewcommanduvec1vechat1\nnewcommandutangentuvectau\nnewcommandunormaluvecn\n\nrenewcommanddmathrmd","category":"page"},{"location":"manual/saddlesystems/#","page":"Saddle point systems","title":"Saddle point systems","text":"using ConstrainedSystems\nusing CartesianGrids\nusing Plots","category":"page"},{"location":"manual/saddlesystems/#","page":"Saddle point systems","title":"Saddle point systems","text":"Saddle systems comprise an important part of solving mechanics problems with constraints. In such problems, there is an underlying system to solve, and the addition of constraints requires that the system is subjected to additional forces (constraint forces, or Lagrange multipliers) that enforce these constraints in the system. Examples of such constrained systems are the divergence-free velocity constraint in incompressible flow (for which pressure is the associated Lagrange multiplier field), the no-slip and/or no-flow-through condition in general fluid systems adjacent to impenetrable bodies, and joint constraints in rigid-body mechanics.","category":"page"},{"location":"manual/saddlesystems/#","page":"Saddle point systems","title":"Saddle point systems","text":"A general saddle-point system has the form","category":"page"},{"location":"manual/saddlesystems/#","page":"Saddle point systems","title":"Saddle point systems","text":"left beginarraycc A  B_1^T  B_2  Cendarrayright left(beginarraycuf endarrayright) = left(beginarraycr_1r_2 endarrayright)","category":"page"},{"location":"manual/saddlesystems/#","page":"Saddle point systems","title":"Saddle point systems","text":"We are primarily interested in cases when the operator A is symmetric and positive semi-definite, which is fairly typical. It is also fairly common for B_1 = B_2, so that the whole system is symmetric.","category":"page"},{"location":"manual/saddlesystems/#","page":"Saddle point systems","title":"Saddle point systems","text":"ConstrainedSystems allows us to solve such systems for u and f in a fairly easy way. We need only to provide rules for how to evaluate the actions of the various operators in the system. Let us use an example to show how this can be done.","category":"page"},{"location":"manual/saddlesystems/#Translating-cylinder-in-potential-flow-1","page":"Saddle point systems","title":"Translating cylinder in potential flow","text":"","category":"section"},{"location":"manual/saddlesystems/#","page":"Saddle point systems","title":"Saddle point systems","text":"In irrotational, incompressible flow, the streamfunction psi satisfies Laplace's equation,","category":"page"},{"location":"manual/saddlesystems/#","page":"Saddle point systems","title":"Saddle point systems","text":"nabla^2 psi = 0","category":"page"},{"location":"manual/saddlesystems/#","page":"Saddle point systems","title":"Saddle point systems","text":"On the surface of an impenetrable body, the streamfunction must obey the constraint","category":"page"},{"location":"manual/saddlesystems/#","page":"Saddle point systems","title":"Saddle point systems","text":"psi = psi_b","category":"page"},{"location":"manual/saddlesystems/#","page":"Saddle point systems","title":"Saddle point systems","text":"where psi_b is the streamfunction associated with the body's motion. Let us suppose the body is moving vertically with velocity 1. Then psi_b = -x for all points inside or on the surface of the body. Thus, the streamfunction field outside this body is governed by Laplace's equation subject to the constraint.","category":"page"},{"location":"manual/saddlesystems/#","page":"Saddle point systems","title":"Saddle point systems","text":"Let us solve this problem on a staggered grid, using the tools discussed in CartesianGrids, including the regularization and interpolation methods to immerse the body shape on the grid. Then our saddle-point system has the form","category":"page"},{"location":"manual/saddlesystems/#","page":"Saddle point systems","title":"Saddle point systems","text":"left beginarraycc L  R  E  0endarrayright left(beginarraycpsif endarrayright) = left(beginarrayc0psi_b endarrayright)","category":"page"},{"location":"manual/saddlesystems/#","page":"Saddle point systems","title":"Saddle point systems","text":"where L is the discrete Laplacian, R is the regularization operator, and E is the interpolation operator.","category":"page"},{"location":"manual/saddlesystems/#","page":"Saddle point systems","title":"Saddle point systems","text":"Physically, f isn't really a force here, but rather, represents the strengths of distributed singularities on the surface. In fact, this strength represents the jump in normal derivative of psi across the surface. Since this normal derivative is equivalent to the tangential velocity, f is the strength of the bound vortex sheet on the surface. This will be useful to know when we check the value of f obtained in our solution.","category":"page"},{"location":"manual/saddlesystems/#","page":"Saddle point systems","title":"Saddle point systems","text":"First, let us set up the body, centered at (11) and of radius 12. We will also initialize a data structure for the force:","category":"page"},{"location":"manual/saddlesystems/#","page":"Saddle point systems","title":"Saddle point systems","text":"using ConstrainedSystems\nusing CartesianGrids\nusing Plots\npyplot()","category":"page"},{"location":"manual/saddlesystems/#","page":"Saddle point systems","title":"Saddle point systems","text":"n = 128; θ = range(0,stop=2π,length=n+1);\nxb = 1.0 .+ 0.5*cos.(θ[1:n]); yb = 1.0 .+ 0.5*sin.(θ[1:n]);\nX = VectorData(xb,yb);\nψb = ScalarData(X);\nf = similar(ψb);","category":"page"},{"location":"manual/saddlesystems/#","page":"Saddle point systems","title":"Saddle point systems","text":"Now let's set up a grid of size 102times 102 (including the usual layer of ghost cells) and physical dimensions 2times 2.","category":"page"},{"location":"manual/saddlesystems/#","page":"Saddle point systems","title":"Saddle point systems","text":"nx = 102; ny = 102; Lx = 2.0; dx = Lx/(nx-2);\nw = Nodes(Dual,(nx,ny));\nψ = similar(w);","category":"page"},{"location":"manual/saddlesystems/#","page":"Saddle point systems","title":"Saddle point systems","text":"We need to set up the operators now. First, the Laplacian:","category":"page"},{"location":"manual/saddlesystems/#","page":"Saddle point systems","title":"Saddle point systems","text":"L = plan_laplacian(size(w),with_inverse=true)","category":"page"},{"location":"manual/saddlesystems/#","page":"Saddle point systems","title":"Saddle point systems","text":"Note that we have made sure that this operator has an inverse. It is important that this operator, which represents the A matrix in our saddle system, comes with an associated backslash \\\\ operation to carry out the inverse.","category":"page"},{"location":"manual/saddlesystems/#","page":"Saddle point systems","title":"Saddle point systems","text":"Now we need to set up the regularization R and interpolation E operators.","category":"page"},{"location":"manual/saddlesystems/#","page":"Saddle point systems","title":"Saddle point systems","text":"regop = Regularize(X,dx;issymmetric=true)\nRmat, Emat = RegularizationMatrix(regop,ψb,w);","category":"page"},{"location":"manual/saddlesystems/#","page":"Saddle point systems","title":"Saddle point systems","text":"Now we are ready to set up the system. The solution and right-hand side vectors are set up using SaddleVector.","category":"page"},{"location":"manual/saddlesystems/#","page":"Saddle point systems","title":"Saddle point systems","text":"rhs = SaddleVector(w,ψb)\nsol = SaddleVector(ψ,f)","category":"page"},{"location":"manual/saddlesystems/#","page":"Saddle point systems","title":"Saddle point systems","text":"and the saddle system is then set up with the three operators; the C operator is presumed to be zero when it is not provided.","category":"page"},{"location":"manual/saddlesystems/#","page":"Saddle point systems","title":"Saddle point systems","text":"A = SaddleSystem(L,Emat,Rmat,rhs)","category":"page"},{"location":"manual/saddlesystems/#","page":"Saddle point systems","title":"Saddle point systems","text":"Note that all of the operators we have provided are either matrices (like Emat and Rmat) or functions or function-like operators (like L). The SaddleSystem constructor allows either. However, the order is important: we must supply A, B_2, B_1^T, and possibly C, in that order.","category":"page"},{"location":"manual/saddlesystems/#","page":"Saddle point systems","title":"Saddle point systems","text":"Let's solve the system. We need to set the right-hand side. We will set ψb, but this will also change rhs, since that vector is pointing to the same object.","category":"page"},{"location":"manual/saddlesystems/#","page":"Saddle point systems","title":"Saddle point systems","text":"ψb .= -(xb.-1);","category":"page"},{"location":"manual/saddlesystems/#","page":"Saddle point systems","title":"Saddle point systems","text":"The right-hand side of the Laplace equation is zero. The right-hand side of the constraint is the specified streamfunction on the body. Note that we have subtracted the circle center from the x positions on the body. The reason for this will be discussed in a moment.","category":"page"},{"location":"manual/saddlesystems/#","page":"Saddle point systems","title":"Saddle point systems","text":"We solve the system with the convenient shorthand of the backslash:","category":"page"},{"location":"manual/saddlesystems/#","page":"Saddle point systems","title":"Saddle point systems","text":"sol .= A\\rhs # hide\n@time sol .= A\\rhs","category":"page"},{"location":"manual/saddlesystems/#","page":"Saddle point systems","title":"Saddle point systems","text":"Just to point out how fast it can be, we have also timed it. It's pretty fast.","category":"page"},{"location":"manual/saddlesystems/#","page":"Saddle point systems","title":"Saddle point systems","text":"We can obtain the state vector and the constraint vector from sol using some convenience functions state(sol) and constraint(sol).","category":"page"},{"location":"manual/saddlesystems/#","page":"Saddle point systems","title":"Saddle point systems","text":"Now, let's plot the solution in physical space. We'll plot the body shape for reference, also.","category":"page"},{"location":"manual/saddlesystems/#","page":"Saddle point systems","title":"Saddle point systems","text":"xg, yg = coordinates(w,dx=dx)\nplot(xg,yg,state(sol),xlim=(-Inf,Inf),ylim=(-Inf,Inf))\nplot!(xb,yb,fillcolor=:black,fillrange=0,fillalpha=0.25,linecolor=:black)\nsavefig(\"sfunc.svg\"); nothing # hide","category":"page"},{"location":"manual/saddlesystems/#","page":"Saddle point systems","title":"Saddle point systems","text":"(Image: )","category":"page"},{"location":"manual/saddlesystems/#","page":"Saddle point systems","title":"Saddle point systems","text":"The solution shows the streamlines for a circle in vertical motion, as expected. All of the streamlines inside the circle are vertical.","category":"page"},{"location":"manual/methods/#Index-1","page":"Index","title":"Index","text":"","category":"section"},{"location":"manual/methods/#","page":"Index","title":"Index","text":"DocTestSetup = quote\n  using ConstrainedSystems\nend","category":"page"},{"location":"manual/methods/#","page":"Index","title":"Index","text":"Modules  = [ConstrainedSystems]\nOrder   = [:type, :function]","category":"page"},{"location":"manual/methods/#ConstrainedSystems.IFHERK","page":"Index","title":"ConstrainedSystems.IFHERK","text":"IFHERK(u,f,Δt,plan_intfact,B₁ᵀ,B₂,r₁,r₂;[tol=1e-3],[issymmetric=false],[rk::RKParams=RK31])\n\nConstruct an integrator to advance a system of the form\n\ndu/dt - Au = -B₁ᵀf + r₁(u,t) B₂u = r₂(u,t)\n\nThe resulting integrator will advance the system (u,f) by one time step, Δt. The optional argument tol sets the tolerance of iterative saddle-point solution, if applicable.\n\nArguments\n\nu : example of state vector data\nf : example of constraint force vector data\nΔt : time-step size\nplan_intfact : constructor to set up integrating factor operator for A that             will act on type u (by left multiplication) and return same type as u\nplan_constraints : constructor to set up the\nB₁ᵀ : operator acting on type f and returning type u\nB₂ : operator acting on type u and returning type f\nr₁ : operator acting on type u and t and returning u\nr₂ : operator acting on type u and t and returning type f\n\n\n\n\n\n","category":"type"},{"location":"manual/methods/#ConstrainedSystems.IFRK","page":"Index","title":"ConstrainedSystems.IFRK","text":"IFRK(u,Δt,plan_intfact,r₁;[rk::RKParams=RK31])\n\nConstruct an integrator to advance a system of the form\n\ndu/dt - Au = r₁(u,t)\n\nThe resulting integrator will advance the state u by one time step, Δt.\n\nArguments\n\nu : example of state vector data\nΔt : time-step size\nplan_intfact : constructor to set up integrating factor operator for A that             will act on type u (by left multiplication) and return same type as u\nr₁ : operator acting on type u and t and returning u\n\n\n\n\n\n","category":"type"},{"location":"manual/methods/#ConstrainedSystems.RK","page":"Index","title":"ConstrainedSystems.RK","text":"RK(u,Δt,r₁;[rk::RKParams=RK31])\n\nConstruct an integrator to advance a system of the form\n\ndu/dt = r₁(u,t)\n\nThe resulting integrator will advance the state u by one time step, Δt.\n\nArguments\n\nu : example of state vector data\nΔt : time-step size\nr₁ : operator acting on type u and t and returning u\n\n\n\n\n\n","category":"type"},{"location":"manual/methods/#ConstrainedSystems.SaddleSystem-Union{Tuple{TS}, Tuple{T}, Tuple{LinearMaps.LinearMap{T},LinearMaps.LinearMap{T},LinearMaps.LinearMap{T},LinearMaps.LinearMap{T},LinearMaps.LinearMap{T},LinearMaps.LinearMap{T},Any,Any}} where TS<:SchurSolverType where T","page":"Index","title":"ConstrainedSystems.SaddleSystem","text":"SaddleSystem\n\nConstruct a saddle-point system operator from the constituent operator blocks. The resulting object can be used with * and \\ to multiply and solve. The saddle-point problem has the form\n\nbeginbmatrixA  B_1^T  B_2  C endbmatrix beginpmatrix u  f endpmatrix = beginpmatrix r_1  r_2 endpmatrix\n\nConstructors\n\nSaddleSystem(A::AbstractMatrix,B₂::AbstractMatrix,B₁ᵀ::AbstractMatrix,C::AbstractMatrix[,eltype=Float64]). Blocks are given as matrices. Must have consistent sizes to stack appropriately. If this is called with SaddleSystem(A,B₂,B₁ᵀ), it sets C to zero automatically.\n\nSaddleSystem(A,B₂,B₁ᵀ,C,u,f[,eltype=Float64]). Operators A, B₂, B₁ᵀ, C are given in various forms, including matrices, functions, and function-like objects. u and f are examples of the data types in the corresponding solution and right-hand side vectors. Guidelines:\n\nThe entries A and B₂ must be able to act upon u (either by multiplication or as a function) and B₁ᵀ and C must be able to act on f (also, either by multiplication or as a function).\nA and B₁ᵀ should return data of type u, and B₂ and C should return data of type f.\nA must be invertible and be outfitted with operators `andldiv!`.\nBoth u and f must be subtypes of AbstractArray: they must be equipped with size and vec functions and with a constructor of the form T(data) where T is the data type of u or f and data is the wrapped data array.\n\nIf called as SaddleSystem(A,B₂,B₁ᵀ,u,f), the C block is omitted and assumed to be zero.\n\nIf called with SaddleSystem(A,u), this is equivalent to calling SaddleSystem(A,nothing,nothing,u,[]), then this reverts to the unconstrained system described by operator A.\n\nThe list of vectors u and f in any of these constructors can be bundled together as a SaddleVector, e.g. SaddleSystem(A,B₂,B₁ᵀ,SaddleVector(u,f)).\n\n\n\n\n\n","category":"method"},{"location":"manual/methods/#ConstrainedSystems.SaddleVector","page":"Index","title":"ConstrainedSystems.SaddleVector","text":"SaddleVector(u,f)\n\nConstruct a vector of a state part u and constraint part f of a saddle-point vector, to be associated with a SaddleSystem.\n\n\n\n\n\n","category":"type"},{"location":"manual/methods/#ConstrainedSystems.System","page":"Index","title":"ConstrainedSystems.System","text":"Abstract type for a system of ODEs\n\n\n\n\n\n","category":"type"},{"location":"manual/methods/#ConstrainedSystems.constraint-Tuple{RecursiveArrayTools.ArrayPartition}","page":"Index","title":"ConstrainedSystems.constraint","text":"constraint(x::SaddleVector)\n\nProvide the constraint part of the given saddle vector x\n\n\n\n\n\n","category":"method"},{"location":"manual/methods/#ConstrainedSystems.state-Tuple{RecursiveArrayTools.ArrayPartition}","page":"Index","title":"ConstrainedSystems.state","text":"state(x::SaddleVector)\n\nProvide the state part of the given saddle vector x\n\n\n\n\n\n","category":"method"},{"location":"manual/methods/#Base.eltype-Union{Tuple{SaddleSystem{T,Ns,Nc,TF,TU,TS} where TS<:SchurSolverType where TU where TF}, Tuple{Nc}, Tuple{Ns}, Tuple{T}} where Nc where Ns where T","page":"Index","title":"Base.eltype","text":"Base.eltype(::SaddleSystem)\n\nReport the element type of a SaddleSystem.\n\n\n\n\n\n","category":"method"},{"location":"manual/methods/#Base.size-Union{Tuple{SaddleSystem{T,Ns,Nc,TF,TU,TS} where TS<:SchurSolverType where TU where TF}, Tuple{Nc}, Tuple{Ns}, Tuple{T}} where Nc where Ns where T","page":"Index","title":"Base.size","text":"Base.size(::SaddleSystem)\n\nReport the size of a SaddleSystem.\n\n\n\n\n\n","category":"method"},{"location":"manual/timemarching/#Time-marching-1","page":"Time marching","title":"Time marching","text":"","category":"section"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"DocTestSetup = quote\nusing ConstrainedSystems\nusing CartesianGrids\nend","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"defddt1fracmathrmd1mathrmdt\n\nrenewcommandvecboldsymbol\nnewcommanduvec1vechat1\nnewcommandutangentuvectau\nnewcommandunormaluvecn\n\nrenewcommanddmathrmd","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"using ConstrainedSystems\nusing CartesianGrids\nusing Plots","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"ConstrainedSystems is equipped with a few classes of time marching schemes for advancing time-dependent equations.","category":"page"},{"location":"manual/timemarching/#Integrating-factor-systems-1","page":"Time marching","title":"Integrating factor systems","text":"","category":"section"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"Integrating factor systems that we encounter in ConstrainedSystems are of the form","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"ddt u = A u + r_1(ut) quad u(0) = u_0","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"The operator A may be a matrix or a scalar, but is generally independent of time. (The   method of integrating factors can deal with time-dependent A, but we don't encounter   such systems in the ConstrainedSystems context so we won't discuss them.) For this purpose, we use the IFRK class of solver, which stands for Integrating Factor Runge-Kutta. This method solves   the part associated with A exactly, via the integrating factor, and advances a modified   equation by Runge-Kutta method to account for the remaining part r_1.","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"We discussed the construction   of the integrating factor in the context of fields in CartesianGrids. But first, let's   give an example of how we can solve a simpler problem with just a single scalar-valued   u. The example we will solve is","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"ddt u = -alpha u + cos(omega t)quad u(0) = u_0","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"The exact solution is easily obtained:","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"u(t) = u_0 e^-alpha t + frac1alpha^2+omega^2 left alpha(cos(omega t) - e^-alpha t) + omega sin (omega t)right","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"Let's solve it numerically, so we can evaluate the accuracy of the solver. We should note that the integrating factor for this system is e^-alpha t.","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"For demonstration, we will set alpha = 1, omega = 4, and u_0 = 1.","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"using ConstrainedSystems\nusing CartesianGrids\nusing Plots\npyplot()","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"α = 1; ω = 4; u₀ = 1.0;","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"Here is the exact solution for later comparison","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"uex(t) = u₀*exp(-α*t) + (α*(cos(ω*t)-exp(-α*t))+ω*sin(ω*t))/(α^2+ω^2)","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"The first steps are to define operators that provide the integrating factor and the right-hand side of the equations. For the integrating factor, we define an extended form of plan_intfact","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"CartesianGrids.plan_intfact(t::Float64,u::Vector{Float64}) = exp(-α*t);","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"Note that we have defined this form of plan_intfact to adhere to the standard form, accepting arguments for time t and the state vector u, even though the state vector isn't strictly needed here. The state 'vector' in this problem is actually only a scalar, of course. But the time marching method does not accept scalar-type states currently, so we will make u a 1-element vector to use the ConstrainedSystems tools.","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"Now let us define the right-hand side function. This function should also adhere to the standard form, which requires the state vector u and the time t as arguments.","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"r₁(u::Vector{Float64},t::Float64) = cos(ω*t);","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"We also need to set the time-step size (001) and the initial condition. For the latter, we set up the state vector as a 1-element vector, as discussed earlier:","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"Δt = 0.01;\nu = [u₀];","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"We can now construct the integrator. We supply a form of the state vector (for use as a template   for pre-allocating space for internal storage variables), the time-step size, and the   definitions of the integrating factor and the right-hand side function:","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"ifrk = IFRK(u,Δt,plan_intfact,r₁,rk=ConstrainedSystems.RK31)","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"We have set the time step size to 001. We have also specified that the Runge-Kutta method to be used is a third-order method, RK31, specially designed for storing as few different versions of the integrating factor as necessary. This is actually the default method, so we could have omitted this keyword argument. There are other choices, as well, such as ConstrainedSystems.Euler for the forward Euler method.","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"Now we can solve the system. The integrator has a simple form, accepting as arguments the current time and state, and returning the updated versions of these at the end of the step. We place this integrator inside of a loop and store the results. (Since u is set up   as a 1-element vector, then we will store only the element of this vector.)","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"uhist = Float64[]; # for storing the solution\nT = 0:Δt:10;\nt = 0.0;\nfor ti in T\n  push!(uhist,u[1]) # storage\n  global t, u = ifrk(t,u) # advancement by one step by the integrator\nend","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"Now we can plot the result and compare it with the exact solution.","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"plot(T,uhist,label=\"numerical\",xlabel=\"t\",ylabel=\"u(t)\")\nplot!(T,uex.(T),label=\"exact soln\")\nsavefig(\"ifrk.svg\"); nothing # hide","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"(Image: )","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"As we can see, the results are nearly indistinguishable.","category":"page"},{"location":"manual/timemarching/#Constrained-systems-1","page":"Time marching","title":"Constrained systems","text":"","category":"section"},{"location":"manual/timemarching/#Constrained-integrating-factor-systems-1","page":"Time marching","title":"Constrained integrating factor systems","text":"","category":"section"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"Constrained integrating factor systems that we encounter in ConstrainedSystems are of the form","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"ddt u = A u - B_1^T f + r_1(ut) quad B_2 u = r_2(ut) quad u(0) = u_0","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"where f is again the Lagrange multiplier for enforcing the constraints on u. Now, we combine the ideas of the last two sections into a single integrator.","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"Let's demonstrate this on the example of heat diffusion from a circular ring whose temperature is held constant. In this case, A is the discrete Laplace operator, L, times the heat diffusivity, r_1 is zero (in the absence of volumetric heating sources), and r_2 is the temperature of the ring. The operators B_1^T and B_2 will be the regularization and interpolation operators between discrete point-wise data on the ring and the field data.","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"The ring will have radius 12 and fixed temperature 1, and the heat diffusivity is 1. (In other words, the problem has been non-dimensionalized by the diameter of the circle, the dimensional ring temperature, and the dimensional diffusivity.)","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"First, we will construct a field to accept the temperature on","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"nx = 129; ny = 129; Lx = 2.0; Δx = Lx/(nx-2);\nu₀ = Nodes(Dual,(nx,ny)); # field initial condition","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"Now set up a ring of points on the circle at center (11).","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"n = 128; θ = range(0,stop=2π,length=n+1);\nR = 0.5; xb = 1.0 .+ R*cos.(θ); yb = 1.0 .+ R*sin.(θ);\nX = VectorData(xb[1:n],yb[1:n]);\nf = ScalarData(X); # to be used as the Lagrange multiplier","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"From this, construct the regularization and interpolation operators in their usual symmetric form, and then set up a routine that will provide these operators inside the integrator:","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"reg = Regularize(X,Δx;issymmetric=true)\nHmat, Emat = RegularizationMatrix(reg,f,u₀);\nplan_constraints(u::Nodes{Dual,nx,ny},t::Float64) = Hmat, Emat","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"Now set up the right-hand side operators. Both must take the standard form, with arguments of the types of u and t. For r_1, we will simply set it to a field of zeros in the same type as u. For r_2, we set the result uniformly to 1.","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"r₁(u::Nodes{T,NX,NY},t::Float64) where {T,NX,NY} = Nodes(T,u); # sets to zeros\nr₂(u::Nodes{T,NX,NY},t::Float64) where {T,NX,NY} = 1.0; # sets uniformly to 1.0","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"We will set the time-step size to a large value (10) for demonstration purposes. The method remains stable for any choice. We also initialize time t and the state u:","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"Δt = 1.0;\nt = 0.0;\nu = deepcopy(u₀);","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"Now we can construct the integrator. We supply examples for the state u and the Lagrange multiplier data f, the time-step size, the constructor for the integrating factor, a tuple of the operators for computing the actions of B_1^T and B_2 on data of type f and u, respectively (which, in this case, are matrices Hmat and Emat), and a tuple of the right-hand side functions.","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"solver = IFHERK(u,f,Δt,CartesianGrids.plan_intfact,plan_constraints,(r₁,r₂),\n                rk=ConstrainedSystems.Euler)","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"Here we've set the method to forward Euler. The resulting integrator accepts as arguments the current time t and the current state u, and returns the time, state, and Lagrange multiplier data at the end of the time step.","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"Now, let's advance the system. We'll also time it.","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"@time for i = 1:20\n  global t, u, f = solver(t,u)\nend","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"Now let's plot it","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"xg, yg = coordinates(u,dx=Δx);\nplot(xg,yg,u)\nplot!(xb,yb,linecolor=:black,linewidth=1.5)\nsavefig(\"ifherk.svg\"); nothing # hide","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"(Image: )","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"From a side view, we can see that it enforces the boundary condition:","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"plot(xg,u[65,:],xlabel=\"x\",ylabel=\"u(x,1)\")\nsavefig(\"ifherk-side.svg\"); nothing # hide","category":"page"},{"location":"manual/timemarching/#","page":"Time marching","title":"Time marching","text":"(Image: )","category":"page"},{"location":"#ConstrainedSystems.jl-1","page":"Home","title":"ConstrainedSystems.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"tools for solving constrained dynamical systems","category":"page"},{"location":"#","page":"Home","title":"Home","text":"defddt1fracmathrmd1mathrmdt\n\nrenewcommandvecboldsymbol\nnewcommanduvec1vechat1\nnewcommandutangentuvectau\nnewcommandunormaluvecn\n\nrenewcommanddmathrmd","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This package contains several tools for solving and advancing (large-scale) dynamical systems with constraints. These systems generically have the form","category":"page"},{"location":"#","page":"Home","title":"Home","text":"ddtu = A u - B_1^T f + r_1(ut) quad B_2 u = r_2(ut) quad u(0) = u_0","category":"page"},{"location":"#","page":"Home","title":"Home","text":"where u is a state vector, A is a linear operator with an associated matrix exponential (integrating factor), and f is a constraint force vector (i.e., Lagrange multipliers).","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Some of the key components of this package are","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Tools for solving linear algebra problems with constraints and associated Lagrange multipliers, known generically as saddle point systems. The sizes of these systems might be large.\nTime integrators that can incorporate these constraints, such as half-explicit Runge-Kutta (HERK) and integrating factor HERK.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The package is agnostic to the type of systems, and might arise from, e.g., fluid dynamics or rigid-body mechanics.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This package works on Julia 1.0 and above and is registered in the general Julia registry. To install from the REPL, type e.g.,","category":"page"},{"location":"#","page":"Home","title":"Home","text":"] add ConstrainedSystems","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Then, in any version, type","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> using ConstrainedSystems","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The plots in this documentation are generated using Plots.jl. You might want to install that, too, to follow the examples.","category":"page"}]
}
